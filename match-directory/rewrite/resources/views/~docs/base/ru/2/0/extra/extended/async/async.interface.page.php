<?php

use Phphleb\Docs\Src\Code;
use Phphleb\Docs\Src\Paragraph;

?>
<?= Paragraph::h1('Сброс состояния для асинхронных запросов') ?>

<p>
    Во фреймворке <span class="notranslate">HLEB2</span> есть возможность выполнять асинхронные запросы, что накладывает дополнительные требования к коду.
    Одно из основных требований - нужно избавляться от хранимого состояния при завершении запроса.
</p>
<p class="hl-info-block">
    Под термином "асинхронность" здесь объединены настоящий асинхронный режим и обычный <span class="notranslate">long-running</span> режим, так как рекомендации к ним одинаковы.
</p>
<p>
    К хранимому состоянию могут относиться данные текущего пользователя, кеш данных запроса, всевозможная мемоизация и т.д.
</p>
<p class="hl-info-block">
    В программировании <i>мемоизация</i> — это метод оптимизации, который делает уже вычисленные данные переиспользуемыми.
    Способ состоит в том, чтобы сохранить в кэше выходные данные метода класса и заставить метод проверять, находится ли каждое требуемое вычисление в кэше, прежде чем вычислять его.
</p>
<p>
    Необходимо определить, какие хранимые состояния относятся к данным запроса, а какие к работе конкретного приложения в целом.
    Например, вычисленное состояние для общей информации о тарифах не будет изменяться от запроса к запросу, а выбранный тариф для каждого пользователя необходимо сбрасывать. При асинхронных запросах следующий запрос может принадлежать другому пользователю и поэтому важно очистить информацию о предыдущем.
</p>

<?= Paragraph::h2('ResetInterface') ?>
<p>
    При помощи <span class="notranslate">ResetInterface</span> реализован современный способ сброса состояния у сервисов в контейнере фреймворка в асинхронном режиме. Это касается только сервисов хранимых как singleton и позволяет при добавлении этого интерфейса и его метода reset сбросить состояние сервиса и проделать прочие действия, подразумеваемые как подготовка к следующему запросу.
</p>
<p>
    Например, в этом демонстрационном сервисе логирования, будет сброшено состояние у логгера <span class="notranslate">Monolog</span> согласно его внутренней реализации одноимённого метода <span class="notranslate">reset</span>:
</p>

<?= Code::fromFile('@views/docs/code/extra/extended/async/interface/default.reset.base.php', false);  ?>

<p>
    Чтобы состояние было сброшено, добавлен интерфейс <span class="notranslate">ResetInterface</span> и реализован метод <span class="notranslate">reset</span>.
</p>

<?= Paragraph::h2('RollbackInterface') ?>
<p>
    Современные практики программирования не рекомендуют пользоваться состоянием, хранимым как статическое свойство класса, но часто оно удобно и забота о нём возникает только при переходе на асинхронный режим.<br>
    Чтобы этот переход был удобным во фреймворке <span class="notranslate">HLEB2</span> есть специальный интерфейс <span class="notranslate">RollbackInterface</span> с одним статическим методом <span class="notranslate">rollback</span>.
</p>
<p>
    Например, есть такое хранимое состояние с данными текущего пользователя (упрощённый код):
</p>

<?= Code::fromFile('@views/docs/code/extra/extended/async/interface/default.state.base.php', false);  ?>

<p>
    Чтобы состояние сбросилось, добавлен интерфейс <span class="notranslate">RollbackInterface</span> и реализован метод <span class="notranslate">rollback</span>:
</p>

<?= Code::fromFile('@views/docs/code/extra/extended/async/interface/new.state.base.php', false);  ?>

<p>
    Теперь при завершении асинхронного запроса фреймворк проверит, есть ли у класса интерфейс <span class="notranslate">RollbackInterface</span> и выполнит метод сброса <span class="notranslate">rollback</span>.
    Необходимо принять во внимание, что метод, сбрасывающий состояние, должен быть идемпотентным и не делать ничего больше. То есть при повторном выполнении результат применения не будет другим.
</p>
<p>
    Для чего нужна идемпотентность видно из следующего, более сложного примера, в котором интерфейс применяется в наследовании (метод сброса может быть вызван дважды):
</p>

<?= Code::fromFile('@views/docs/code/extra/extended/async/interface/parent.state.base.php', false);  ?>


<p class="hl-info-block">
    Если необходимо выполнить какое-либо действие по завершению асинхронного запроса, не связанное со сбросом состояния в конкретном классе, то его можно добавить в метод <span class="notranslate">rollback</span> класса <span class="notranslate">App\Bootstrap\ContainerFactory</span>.
</p>


<?php insertTemplate('/docs/ru/authors'); ?>

<?php insertTemplate('/docs/ru/footer'); ?>

